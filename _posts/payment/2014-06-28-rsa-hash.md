---
layout: post
title: 非对称算法，散列(Hash)以及证书的那些事
category: payment
tags: [rsa,hash,证书]
---

>这几个概念在金融电子支付领域用得比较多，我忽然觉得把它们串起来一起讲,层层引入，可能更好理解一些。希望能以最简单朴实的方式讲明白他们之间的关系。

## 非对称算法

关于非对称算法，你只要知道下面这些就行了，密钥是一对，一个叫公钥，一个叫私钥，前者公开，后者保密。假设你有一对公私钥，给你一串数据，你可以用私钥加密，然后把密文和公钥都放出去，别人可以用这个公钥解密。同样反过来，别人也可以用这个公钥加密一串数据，你用对应的私钥解密。可以用下图来表示:


![](https://img-blog.csdn.net/20140628003451937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9ueV9tYWdnaWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


## 散列

散列也叫哈希，学过数据结构的人对这个概念都不陌生。简单来讲，给你一串数据A，这个数据可以很长，你通过一个算法把它们转变成一个很短的固定长度（不管源串有多长）的另一串数据B。这个过程就叫散列，数据B叫数据A的散列值(或者叫哈希值，或者叫摘要)。

再深入一些。大部分情况下，A和B是一一对应的（这也是我们希望的），也就是说，如果我还有个A1,那么它的散列值B1和B不会相等。但是理想丰满，现实让人反感，B1有可能和B相等。这种现象有个学名叫”碰撞”，增加散列值的位数是防碰撞的一个方法，因为很自然位数越长，完全相同的概率就越小。目前认为超过128位的散列值都能很好的防碰撞。后面我们讲到签名时，假定是没有碰撞的。
 
最后再补充一点，散列具有不可逆性，也就是你没法从B还原回A,即使散列算法是公开的。
 

## 数字签名

生活中我们用签名代表自己的身份，比如领导签署一个文件，大家看到这个签名，就确认是这个领导签的，就代表他本人。签名只占用很小的信息(一般是两个字或三个字，日本人的可能长一些)，却能表示你整个人的信息，这种思想确实意义很大，我们把它用在电子化的签名过程，也就是数字签名。

数字签名的过程是这样的，比如小明有一串数据A要发给小红，小明先用散列生成一个A的摘要B，然后把B用一个私钥加密后附在A的后面发给小红，小红有公钥(因为是公开的)，她先用这个公钥解密A后面的数据得到B，然后自己把A散列一些算出一个B1, 比较B1和B如果相等，首先能说明数据是小明发过来的，因为只有小明才有私钥，其次能说明A在传输过程中没有被改过，因为如果修改过，散列值肯定不相等。上述过程可以用下图说明:

![](https://img-blog.csdn.net/20140628003732781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9ueV9tYWdnaWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


可能有有会有问题，数据A似乎没有加密？，确实是这样，因为这个不是小红所关心的，小红只关心这个数据是不是小明发的，数据的内容没那么重要。其实也不难理解，就跟你去超市刷卡购物一样，小票需要你签字作为对账的凭证，人们只关心这个签名是不是你本人的，对于小票的内容没这么关心。

## 证书

仔细想想上面的验证签名的过程，似乎天衣无缝。但其实有个问题，小红的公钥是哪来的？有人说这个不是公开的吗，随便哪都可以，可以是问别人要的，可以是网上找的。其实不然，验签的前提，是小红已经假设她手上的公钥和小明的私钥是一对的。如果小王生成一对非法的公私钥对，然后给小红公钥，给她说这是小明的，就会产生问题了。所以小红要有明确的途径确认她的公钥是合法的。

打个比方，一个人站在你面前，你没法判断他是好人还是坏人，但是如果法院告诉你这个人是杀人犯，你肯定会选择相信，因为法院是权威机构。同样的，对于公钥这样的”公开的敏感信息”,也需要一个权威机构来认定。这个机构叫CA(certification authority)。这样小红只要是从CA拿的公钥，就可以认为它是合法的了。

CA一般不会直接下发公钥，它通常把公钥信息和一些附加信息(比如公钥产生的日期，有效期等)一起按照一定的格式组织起来下发，这种组织起来的数据就叫做证书。证书的作用就是它有一定的格式，这个格式还是个标准，全世界都用它，这样就很方便传播。目前用得比较多的证书就是著名的x.509。





